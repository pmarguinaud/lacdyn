#include "simple4.h"
#define ATTR_ARG

USE PARKIND1,  ONLY : JPIM, JPRB

USE LOAD_MOD
USE YOMGMV,    ONLY : TGMV
USE YOMOROG,   ONLY : TOROG
USE YOMGSGEOM, ONLY : TGSGEOM
USE YOMDIMV  , ONLY : YRDIMV

IMPLICIT NONE


INTEGER(KIND=JPIM)               :: KIDIA 
INTEGER(KIND=JPIM)               :: KFDIA 
REAL(KIND=JPRB)                  :: PBETADT 
REAL(KIND=JPRB)                  :: PDT 
INTEGER(KIND=JPIM), ALLOCATABLE  :: IFDIA (:)


INTEGER :: IBL, ICOUNT, KLON, JJ, JIDIA, JFDIA
INTEGER :: KPSTSZ, KPSTPT
INTEGER :: ICOUNT1, KLON1
INTEGER :: ICOUNT0, KLON0
LOGICAL :: LLDIFF
CHARACTER (LEN=32) :: CLCASE
INTEGER, POINTER :: IDIFFBLOCK (:) => NULL ()

#include "notfunny.intfb.h"



KLON0 = KLON; ICOUNT0 = ICOUNT
KLON = KLON1; ICOUNT = ICOUNT1

KIDIA = 1
KFDIA = 64


KPSTSZ = 15 * YRDIMV%NFLEVG
KPSTPT = 1


PRINT *, "-- RUN",KIDIA,KFDIA
#ifdef ACC
!$acc parallel loop gang vector private(IBL) collapse(2)
#else
!$OMP PARALLEL DO PRIVATE (IBL,JJ,JIDIA,JFDIA)
#endif
DO IBL = 1, 1
  DO JJ = KIDIA, KFDIA
    JIDIA=JJ
    JFDIA=JJ
    CALL notfunny(JJ,JJ)
!   CALL notfunny(JIDIA,JFDIA)
  ENDDO

ENDDO
#ifdef ACC
!$acc end parallel
#else
!$OMP END PARALLEL DO
#endif


CONTAINS

SUBROUTINE SETALLI1 (KALL, LDPROMA)

INTEGER (KIND=JPIM) ATTR_ARG, POINTER :: KALL (:,:)
INTEGER (KIND=JPIM), POINTER :: K (:)
LOGICAL, OPTIONAL :: LDPROMA
INTEGER :: JLON, JLON1, IBL1, IBL1R, IGP
INTEGER (KIND=JPIM), ALLOCATABLE :: JJ1 (:)
INTEGER (KIND=JPIM) :: KLB (1), KUB (1)
LOGICAL :: LLPROMA

LLPROMA = .TRUE.
IF (PRESENT (LDPROMA)) LLPROMA = LDPROMA

CALL LOAD (ILUN_IN, K)

IF (LLPROMA) THEN
  
  IF (IBL == 1) THEN
    ALLOCATE (KALL (KLON1, ICOUNT1))
  ENDIF
  
  DO JLON = 1, IFDIA (IBL)
    IGP = JLON + (IBL - 1) * KLON
    IBL1 = 1 + (IGP - 1) / KLON1
    JLON1 = 1 + MODULO (IGP - 1, KLON1)
    IF (IBL1 <= ICOUNT1) THEN
      KALL (JLON1, IBL1) = K(JLON)
    ENDIF
  ENDDO
  DO JLON = IFDIA (IBL)+1, KLON
    IGP = JLON + (IBL - 1) * KLON
    IBL1 = 1 + (IGP - 1) / KLON1
    JLON1 = 1 + MODULO (IGP - 1, KLON1)
    IF (IBL1 <= ICOUNT1) THEN
      KALL (JLON1, IBL1) = K (IFDIA (IBL))
    ENDIF
  ENDDO
  
  IF (IBL == ICOUNT) THEN
    ALLOCATE (JJ1 (KLON1))
    IGP = IBL * KLON
    IBL1R = (IGP - 1) / KLON1
    DO IBL1 = IBL1R + 1, ICOUNT1
      JJ1 (:) = KALL (:, 1 + MODULO (IBL1, IBL1R))
      KALL (:, IBL1) = JJ1 (:)
    ENDDO
    DEALLOCATE (JJ1)
  ENDIF

ELSE

  KLB = LBOUND (K)
  KUB = UBOUND (K)

  IF (IBL == 1) THEN
    ALLOCATE (KALL (KLB (1):KUB (1), ICOUNT1))
  ENDIF

  KALL (:,1) = K

  IF (IBL == ICOUNT) THEN
    ALLOCATE (JJ1 (KLB (1):KUB (1)))
    DO IBL1 = 2, ICOUNT1
      JJ1 (:) = KALL (:,1)
      KALL (:,IBL1) = JJ1 (:)
    ENDDO
    DEALLOCATE (JJ1)
  ENDIF


ENDIF

DEALLOCATE (K)
NULLIFY (K)

END SUBROUTINE

END 
