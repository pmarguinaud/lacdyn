SUBROUTINE SETALLI1 (KALL, LDPROMA)

INTEGER (KIND=JPIM) , POINTER :: KALL (:,:)
INTEGER (KIND=JPIM), POINTER :: K (:)
LOGICAL, OPTIONAL :: LDPROMA
INTEGER :: JLON, JLON1, IBL1, IBL1R, IGP
INTEGER (KIND=JPIM), ALLOCATABLE :: JJ1 (:)
INTEGER (KIND=JPIM) :: KLB (1), KUB (1)
LOGICAL :: LLPROMA

LLPROMA = .TRUE.
IF (PRESENT (LDPROMA)) LLPROMA = LDPROMA

CALL LOAD (ILUN_IN, K)

IF (LLPROMA) THEN
  
  IF (IBL == 1) THEN
    ALLOCATE (KALL (KLON1, ICOUNT1))
  ENDIF
  
  DO JLON = 1, IFDIA (IBL)
    IGP = JLON + (IBL - 1) * KLON
    IBL1 = 1 + (IGP - 1) / KLON1
    JLON1 = 1 + MODULO (IGP - 1, KLON1)
    IF (IBL1 <= ICOUNT1) THEN
      KALL (JLON1, IBL1) = K(JLON)
    ENDIF
  ENDDO
  DO JLON = IFDIA (IBL)+1, KLON
    IGP = JLON + (IBL - 1) * KLON
    IBL1 = 1 + (IGP - 1) / KLON1
    JLON1 = 1 + MODULO (IGP - 1, KLON1)
    IF (IBL1 <= ICOUNT1) THEN
      KALL (JLON1, IBL1) = K (IFDIA (IBL))
    ENDIF
  ENDDO
  
  IF (IBL == ICOUNT) THEN
    ALLOCATE (JJ1 (KLON1))
    IGP = IBL * KLON
    IBL1R = (IGP - 1) / KLON1
    DO IBL1 = IBL1R + 1, ICOUNT1
      JJ1 (:) = KALL (:, 1 + MODULO (IBL1, IBL1R))
      KALL (:, IBL1) = JJ1 (:)
    ENDDO
    DEALLOCATE (JJ1)
  ENDIF

ELSE

  KLB = LBOUND (K)
  KUB = UBOUND (K)

  IF (IBL == 1) THEN
    ALLOCATE (KALL (KLB (1):KUB (1), ICOUNT1))
  ENDIF

  KALL (:,1) = K

  IF (IBL == ICOUNT) THEN
    ALLOCATE (JJ1 (KLB (1):KUB (1)))
    DO IBL1 = 2, ICOUNT1
      JJ1 (:) = KALL (:,1)
      KALL (:,IBL1) = JJ1 (:)
    ENDDO
    DEALLOCATE (JJ1)
  ENDIF


ENDIF

DEALLOCATE (K)
NULLIFY (K)

END SUBROUTINE

SUBROUTINE SETALLI2 (KALL)

INTEGER (KIND=JPIM) , POINTER :: KALL (:,:,:)
INTEGER (KIND=JPIM), POINTER :: K (:,:)
INTEGER :: KLB (2), KUB (2), JLON, JLON1, IBL1R, IBL1, IGP
INTEGER (KIND=JPIM), ALLOCATABLE :: JJ2 (:,:)

CALL LOAD (ILUN_IN, K)

KLB = LBOUND (K)
KUB = UBOUND (K)

IF (IBL == 1) THEN
  ALLOCATE (KALL (KLON1, KLB (2):KUB (2), ICOUNT1))
ENDIF

DO JLON = 1, IFDIA (IBL)
  IGP = JLON + (IBL - 1) * KLON
  IBL1 = 1 + (IGP - 1) / KLON1
  JLON1 = 1 + MODULO (IGP - 1, KLON1)
  IF (IBL1 <= ICOUNT1) THEN
    KALL (JLON1,:,IBL1) = K (JLON, :)
  ENDIF
ENDDO
DO JLON = IFDIA (IBL)+1, KLON
  IGP = JLON + (IBL - 1) * KLON
  IBL1 = 1 + (IGP - 1) / KLON1
  JLON1 = 1 + MODULO (IGP - 1, KLON1)
  IF (IBL1 <= ICOUNT1) THEN
    KALL (JLON1,:,IBL1) = K (IFDIA (IBL), :)
  ENDIF
ENDDO

IF (IBL == ICOUNT) THEN
  ALLOCATE (JJ2 (KLON1, KLB (2):KUB (2)))
  IGP = IBL * KLON
  IBL1R = (IGP - 1) / KLON1
  DO IBL1 = IBL1R + 1, ICOUNT1
    JJ2 (:,:) = KALL (:,:,1 + MODULO (IBL1, IBL1R))
    KALL (:,:,IBL1) = JJ2 (:,:)
  ENDDO
  DEALLOCATE (JJ2)
ENDIF

DEALLOCATE (K)
NULLIFY (K)

END SUBROUTINE

SUBROUTINE SETALLX1 (PALL, LDPROMA)

REAL (KIND=JPRB) , POINTER :: PALL (:,:)
REAL (KIND=JPRB), POINTER :: P (:)
LOGICAL, OPTIONAL :: LDPROMA
INTEGER :: KLB (1), KUB (1), JLON, JLON1, IBL1, IBL1R, IGP
REAL (KIND=JPRB), ALLOCATABLE :: ZZ1 (:)
LOGICAL :: LLPROMA

LLPROMA = .TRUE.
IF (PRESENT (LDPROMA)) LLPROMA = LDPROMA

CALL LOAD (ILUN_IN, P)

IF (LLPROMA) THEN

  IF (IBL == 1) THEN
    ALLOCATE (PALL (KLON1, ICOUNT1))
  ENDIF

  DO JLON = 1, IFDIA (IBL)
    IGP = JLON + (IBL - 1) * KLON
    IBL1 = 1 + (IGP - 1) / KLON1
    JLON1 = 1 + MODULO (IGP - 1, KLON1)
    IF (IBL1 <= ICOUNT1) THEN
      PALL (JLON1, IBL1) = P (JLON)
    ENDIF
  ENDDO
  DO JLON = IFDIA (IBL)+1, KLON
    IGP = JLON + (IBL - 1) * KLON
    IBL1 = 1 + (IGP - 1) / KLON1
    JLON1 = 1 + MODULO (IGP - 1, KLON1)
    IF (IBL1 <= ICOUNT1) THEN
      PALL (JLON1, IBL1) = P (IFDIA (IBL))
    ENDIF
  ENDDO

  IF (IBL == ICOUNT) THEN
    ALLOCATE (ZZ1 (KLON1))
    IGP = IBL * KLON
    IBL1R = (IGP - 1) / KLON1
    DO IBL1 = IBL1R + 1, ICOUNT1
      ZZ1 (:) = PALL (:, 1 + MODULO (IBL1, IBL1R))
      PALL (:, IBL1) = ZZ1 (:)
    ENDDO
    DEALLOCATE (ZZ1)
  ENDIF

ELSE

  KLB = LBOUND (P)
  KUB = UBOUND (P)

  IF (IBL == 1) THEN
    ALLOCATE (PALL (KLB (1):KUB (1), ICOUNT1))
  ENDIF

  PALL (:,1) = P

  IF (IBL == ICOUNT) THEN
    ALLOCATE (ZZ1 (KLB (1):KUB (1)))
    DO IBL1 = 2, ICOUNT1
      ZZ1 (:) = PALL (:,1)
      PALL (:,IBL1) = ZZ1 (:)
    ENDDO
    DEALLOCATE (ZZ1)
  ENDIF

ENDIF

DEALLOCATE (P)
NULLIFY (P)

END SUBROUTINE

SUBROUTINE SETALLX2 (PALL, LDPROMA)

REAL (KIND=JPRB) , POINTER :: PALL (:,:,:)
REAL (KIND=JPRB), POINTER :: P (:,:)
LOGICAL, OPTIONAL :: LDPROMA
INTEGER :: KLB (2), KUB (2), JLON, JLON1, IBL1R, IBL1, IGP
REAL (KIND=JPRB), ALLOCATABLE :: ZZ2 (:,:)
LOGICAL :: LLPROMA

LLPROMA = .TRUE.
IF (PRESENT (LDPROMA)) LLPROMA = LDPROMA

CALL LOAD (ILUN_IN, P)

KLB = LBOUND (P)
KUB = UBOUND (P)

IF (LLPROMA) THEN

  IF (IBL == 1) THEN
    ALLOCATE (PALL (KLON1, KLB (2):KUB (2), ICOUNT1))
  ENDIF
  
  DO JLON = 1, IFDIA (IBL)
    IGP = JLON + (IBL - 1) * KLON
    IBL1 = 1 + (IGP - 1) / KLON1
    JLON1 = 1 + MODULO (IGP - 1, KLON1)
    IF (IBL1 <= ICOUNT1) THEN
      PALL (JLON1, :, IBL1) = P (JLON, :)
    ENDIF
  ENDDO
  DO JLON = IFDIA (IBL)+1, KLON
    IGP = JLON + (IBL - 1) * KLON
    IBL1 = 1 + (IGP - 1) / KLON1
    JLON1 = 1 + MODULO (IGP - 1, KLON1)
    IF (IBL1 <= ICOUNT1) THEN
      PALL (JLON1, :, IBL1) = P (IFDIA (IBL), :)
    ENDIF
  ENDDO
  
  IF (IBL == ICOUNT) THEN
    ALLOCATE (ZZ2 (KLON1, KLB (2):KUB (2)))
    IGP = IBL * KLON
    IBL1R = (IGP - 1) / KLON1
    DO IBL1 = IBL1R + 1, ICOUNT1
      ZZ2 (:,:) = PALL (:, :, 1 + MODULO (IBL1, IBL1R))
      PALL (:, :, IBL1) = ZZ2 (:,:)
    ENDDO
    DEALLOCATE (ZZ2)
  ENDIF

ELSE

  KLB = LBOUND (P)
  KUB = UBOUND (P)

  IF (IBL == 1) THEN
    ALLOCATE (PALL (KLB (1):KUB (1), KLB (2):KUB (2), ICOUNT1))
  ENDIF

  PALL (:,:,1) = P

  IF (IBL == ICOUNT) THEN
    ALLOCATE (ZZ2 (KLB (1):KUB (1),KLB (2):KUB (2)))
    DO IBL1 = 2, ICOUNT1
      ZZ2 (:,:) = PALL (:,:,1)
      PALL (:,:,IBL1) = ZZ2 (:,:)
    ENDDO
    DEALLOCATE (ZZ2)
  ENDIF


ENDIF

DEALLOCATE (P)
NULLIFY (P)

END SUBROUTINE

SUBROUTINE SETALLX3 (PALL, LDPROMA)

REAL (KIND=JPRB) , POINTER :: PALL (:,:,:,:)
REAL (KIND=JPRB), POINTER :: P (:,:,:)
LOGICAL, OPTIONAL :: LDPROMA
INTEGER :: KLB (3), KUB (3), JLON, JLON1, IBL1R, IBL1, IGP
REAL (KIND=JPRB), ALLOCATABLE :: ZZ3 (:,:,:)
LOGICAL :: LLPROMA

LLPROMA = .TRUE.
IF (PRESENT (LDPROMA)) LLPROMA = LDPROMA

CALL LOAD (ILUN_IN, P)

KLB = LBOUND (P)
KUB = UBOUND (P)

IF (LLPROMA) THEN

  IF (IBL == 1) THEN
    ALLOCATE (PALL (KLON1, KLB (2):KUB (2), KLB (3):KUB (3), ICOUNT1))
  ENDIF
  
  DO JLON = 1, IFDIA (IBL)
    IGP = JLON + (IBL - 1) * KLON
    IBL1 = 1 + (IGP - 1) / KLON1
    JLON1 = 1 + MODULO (IGP - 1, KLON1)
    IF (IBL1 <= ICOUNT1) THEN
      PALL (JLON1, :, :, IBL1) = P (JLON, :, :)
    ENDIF
  ENDDO
  DO JLON = IFDIA (IBL)+1, KLON
    IGP = JLON + (IBL - 1) * KLON
    IBL1 = 1 + (IGP - 1) / KLON1
    JLON1 = 1 + MODULO (IGP - 1, KLON1)
    IF (IBL1 <= ICOUNT1) THEN
      PALL (JLON1, :, :, IBL1) = P (IFDIA (IBL), :, :)
    ENDIF
  ENDDO
  
  IF (IBL == ICOUNT) THEN
    ALLOCATE (ZZ3 (KLON1, KLB (2):KUB (2), KLB (3):KUB (3)))
    IGP = IBL * KLON
    IBL1R = (IGP - 1) / KLON1
    DO IBL1 = IBL1R + 1, ICOUNT1
      ZZ3 (:,:,:) = PALL (:, :, :, 1 + MODULO (IBL1, IBL1R))
      PALL (:, :, :, IBL1) = ZZ3 (:,:,:)
    ENDDO
    DEALLOCATE (ZZ3)
  ENDIF

ELSE

  KLB = LBOUND (P)
  KUB = UBOUND (P)

  IF (IBL == 1) THEN
    ALLOCATE (PALL (KLB (1):KUB (1), KLB (2):KUB (2), KLB (3):KUB (3), ICOUNT1))
  ENDIF

  PALL (:,:,:,1) = P

  IF (IBL == ICOUNT) THEN
    ALLOCATE (ZZ3 (KLB (1):KUB (1),KLB (2):KUB (2),KLB (3):KUB (3)))
    DO IBL1 = 2, ICOUNT1
      ZZ3 (:,:,:) = PALL (:,:,:,1)
      PALL (:,:,:,IBL1) = ZZ3 (:,:,:)
    ENDDO
    DEALLOCATE (ZZ3)
  ENDIF

ENDIF

DEALLOCATE (P)
NULLIFY (P)

END SUBROUTINE

SUBROUTINE DDIFFX1 (CDNAME, PALL, LDPRINT)

CHARACTER(LEN=*) :: CDNAME
LOGICAL :: LDPRINT
REAL (KIND=JPRB)  :: PALL (:,:)
REAL (KIND=JPRB), POINTER :: P (:)
REAL (KIND=JPRB), POINTER :: ZALL (:)

CALL LOAD (ILUN_OUT, P)

IF (KFDIA == IFDIA (IBL) .AND. LDPRINT) THEN
  ALLOCATE (ZALL (LBOUND (PALL, 1):UBOUND (PALL, 1)))
  ZALL = PALL (:, IBL)
  CALL DIFF (CDNAME, ZALL, P)
  DEALLOCATE (ZALL)
ENDIF

DEALLOCATE (P)

END SUBROUTINE

SUBROUTINE DDIFFX2 (CDNAME, PALL, LDPRINT)

CHARACTER(LEN=*) :: CDNAME
LOGICAL :: LDPRINT
REAL (KIND=JPRB)  :: PALL (:,:,:)
REAL (KIND=JPRB), POINTER :: P (:,:)
REAL (KIND=JPRB), POINTER :: ZALL (:,:)

CALL LOAD (ILUN_OUT, P)

IF (KFDIA == IFDIA (IBL) .AND. LDPRINT) THEN
  ALLOCATE (ZALL (LBOUND (PALL, 1):UBOUND (PALL, 1), LBOUND (PALL, 2):UBOUND (PALL, 2)))
  ZALL = PALL (:,:,IBL)
  CALL DIFF (CDNAME, ZALL, P)
  DEALLOCATE (ZALL)
ENDIF

DEALLOCATE (P)

END SUBROUTINE

SUBROUTINE DDIFFX3 (CDNAME, PALL, LDPRINT)

CHARACTER(LEN=*) :: CDNAME
LOGICAL :: LDPRINT
REAL (KIND=JPRB)  :: PALL (:,:,:,:)
REAL (KIND=JPRB), POINTER :: P (:,:,:)
REAL (KIND=JPRB), POINTER :: ZALL (:,:,:)

CALL LOAD (ILUN_OUT, P)

IF (KFDIA == IFDIA (IBL) .AND. LDPRINT) THEN
  ALLOCATE (ZALL (LBOUND (PALL, 1):UBOUND (PALL, 1), &
                  LBOUND (PALL, 2):UBOUND (PALL, 2), &
                  LBOUND (PALL, 3):UBOUND (PALL, 3)))
  ZALL = PALL (:, :, :, IBL)
  CALL DIFF (CDNAME, ZALL, P)
  DEALLOCATE (ZALL)
ENDIF

DEALLOCATE (P)

END SUBROUTINE



